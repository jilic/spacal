/**
 * @file
 * @brief A Wolfram calo block with scintilator tubes
 * @author Jelena Ilic
 * @date 14/02/14
 */

#include "SPcPMTSD.hh"
#include "SPcScintSD.hh"
#include "TubeParameterisation.hh"
#include "G4PVParameterised.hh"
#include "DetectorConstruction.hh"
#include "DetectorMessenger.hh"
#include "G4LogicalSkinSurface.hh"
#include "G4MagneticField.hh"
#include "G4UniformMagField.hh"
#include "G4FieldManager.hh"
#include "G4TransportationManager.hh"
#include "G4MagIntegratorStepper.hh"
#include "G4Mag_UsualEqRhs.hh"
#include "G4ClassicalRK4.hh"
#include "G4ExplicitEuler.hh"
#include "G4ChordFinder.hh"
#include "G4EqMagElectricField.hh"
#include "G4PropagatorInField.hh"

#include "G4Material.hh"
#include "G4Box.hh"
#include "G4Tubs.hh"
#include "G4LogicalVolume.hh"
#include "G4PVPlacement.hh"
#include "G4PVReplica.hh"
 
#include "G4GeometryTolerance.hh"
#include "G4GeometryManager.hh"
#include "G4NistManager.hh"
#include "G4PropagatorInField.hh"
#include "G4OpBoundaryProcess.hh"
#include "G4LogicalBorderSurface.hh"

#include "G4VisAttributes.hh"
#include "G4Colour.hh"

#include "G4SolidStore.hh"
#include "G4LogicalVolumeStore.hh"
#include "G4PhysicalVolumeStore.hh"
#include "G4RunManager.hh"

//#include "SensitiveDetector.hh"
#include "G4SDManager.hh"
// units
#include "G4PhysicalConstants.hh"
#include "G4SystemOfUnits.hh"
#include "G4UIcmdWithADoubleAndUnit.hh"

SPcPMTSD* DetectorConstruction::fPmt_SD=NULL;
SPcScintSD* DetectorConstruction::fScint_SD=NULL;

G4SDManager* SDman = G4SDManager::GetSDMpointer();

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
DetectorConstruction::DetectorConstruction()
:ej309_mt(NULL)
{
	air = vacuum = wolfram = quartz = ej309 = fGlass = fAl = NULL;
	
	fUpdated = false;
	
	SetDefaults();

	fDetectorMessenger = new DetectorMessenger(this);

}
 
//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
DetectorConstruction::~DetectorConstruction()
{
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
void DetectorConstruction::SetDefaults() 
{
	//This function defines the defaults of the geometry construction

	// ** world **
	halfWorldLength = 1300*mm;

	// ** em calo **
	emCaloWidth               = 50*mm;//50*mm
	emCaloLength              = 100*mm;
	posEmCalo = -G4ThreeVector(0,0,emCaloLength/2);
	dice5=false;

	// ** Tubes and Capillaries **
	capillaryOutherR = 0.4*mm;
	coreOutherR = 0.2*mm;

	// ** Distance between capillaries **
	pitch 		= 1.2*mm;

	// ** Magnetic Field **
	fieldValueX = 0.0*tesla;
	fieldValueY = 0.0*tesla;
	fieldValueZ = 3.8*tesla;

	// ** PMTs **
	fNx = fNy =0;
	fD_mtl 	= 0.0635*cm; // pmt's tickness
	pmtZ 	  = 10*cm;//0.0635*cm 
	
	fUpdated=true;

}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
void DetectorConstruction::ConstructField() 
{
	static G4TransportationManager* trMgr = G4TransportationManager::GetTransportationManager(); 

	// A field object is held by a field manager
	// Find the global Field Manager
	G4FieldManager* globalFieldMgr = trMgr->GetFieldManager();

	static G4bool fieldIsInitialized = false;
	if(!fieldIsInitialized){

		G4MagneticField* myField = 0;
		G4ThreeVector  fieldVector(  fieldValueX, fieldValueY, fieldValueZ );      

		myField = new G4UniformMagField( fieldVector ); 
		//The ChordFinder is an helper class to track particles 
		//in magnetic fields, it sets the accuracy to be used.      
		globalFieldMgr->CreateChordFinder(myField);      
		globalFieldMgr->SetDetectorField(myField);

		G4cout << "Magnetic field has been constructed " << "in DetectorConstruction::ConstructField()" << G4endl;
		fieldIsInitialized = true; 
	}
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
void DetectorConstruction::DefineMaterials() 
{
	G4double a;  // atomic mass
	G4double z;  // atomic number
	G4double density;
	//Get Materials from NIST database
	G4NistManager* man = G4NistManager::Instance();
	man->SetVerbose(0);
	//Elements
	G4Element* O  = new G4Element("Oxygen",	"O",	8.,	16.00*g/mole);
	G4Element* Si = new G4Element("Silicon","Si",	14.,28.09*g/mole);
	G4Element* H = new G4Element("Hidrogen","H",	1.,	1.00794*g/mole);
	G4Element* C = new G4Element("Carbon",	"C",	6., 12.011*g/mole);

	//Build materials

	// -------EJ309____________________
	G4double density_ej309 = 0.959*g/cm3;
	ej309 = new G4Material("ej309", density_ej309, 2);
	ej309->AddElement(H, 0.09849); //H:C ratio = 1.25 (from www.eljentechnology.com)
	ej309->AddElement(C, 0.90151);  //H:C ratio = 1.25 (from www.eljentechnology.com)

	//Add optical properties
	const G4int numBins=11;
	G4double energy_ej309[numBins] = { 
		2.360*eV, 2.626*eV, 2.848*eV, 2.888*eV, 2.933*eV,
		3.017*eV, 3.052*eV, 3.122*eV, 3.175*eV, 3.210*eV,
		3.264*eV};// lambda range 
	G4double rindex_ej309[numBins] = { 
		1.57, 1.57, 1.57, 1.57, 1.57,
		1.57, 1.57, 1.57, 1.57, 1.57,
		1.57};          // ref index
	G4double absorp_ej309[numBins] = { 
		2.0*m, 2.0*m, 2.0*mm, 2*m, 2*m,
		2.0*m, 2.0*m, 2.0*mm, 2*m, 2*m,
		2.0*m};       // atten length www.eljentechnology.com says >1m
	G4double ScintilSlow[numBins]={ 
		0.1,0.4,0.8,0.9,1.0,
		0.8,0.7,0.6,0.4,0.2,
		0.0};
	// trick to reduce the number of optical photons tracked:
	// default values
	G4double	actSY = 11500.; // actual scintillator yield (photons/MeV) www.eljentechnology.com
	G4double	pmtEff = 0.20;  // 20% Q.E. of PMTs (PMT quantum efficiency )
	G4double	effSY = actSY*pmtEff;

	ej309_mt = new G4MaterialPropertiesTable();
	ej309_mt->AddProperty("RINDEX", 	energy_ej309, rindex_ej309,	numBins);
	ej309_mt->AddProperty("ABSLENGTH", 	energy_ej309, absorp_ej309,	numBins);
	ej309_mt->AddProperty("SLOWCOMPONENT",energy_ej309, ScintilSlow,numBins);
	ej309_mt->AddConstProperty("SCINTILLATIONYIELD", actSY/MeV );
	ej309_mt->AddConstProperty("SLOWTIMECONSTANT", 3.5*ns);
	ej309_mt->AddConstProperty("RESOLUTIONSCALE",1.0);
	ej309->SetMaterialPropertiesTable(ej309_mt);

    // Set the Birks Constant for the SPc scintillator
    ej309->GetIonisation()->SetBirksConstant(0.01*mm/MeV);

	//----------quartz_____________
	quartz = new G4Material("quartz", 2.200*g/cm3, 2);
	quartz->AddElement(Si, 1);
	quartz->AddElement(O , 2);

	// from http://www.crystran.co.uk/optical-materials/quartz-crystal-sio2
	const G4int NUMENTRIES_quartz = 29;
	G4double energy_quartz[NUMENTRIES_quartz] = {
		6.42*eV, 5.82*eV, 5.58*eV, 5.49*eV, 5.00*eV, 4.82*eV,
		4.43*eV, 4.03*eV, 3.81*eV, 3.53*eV, 3.10*eV, 2.71*eV,
		2.54*eV, 2.41*eV, 2.33*eV, 2.10*eV, 1.96*eV, 1.85*eV,
		1.64*eV, 1.79*eV, 1.59*eV, 1.55*eV, 1.51*eV, 1.44*eV,
		1.27*eV, 1.17*eV, 0.94*eV, 0.80*eV, 0.62*eV};

	G4double rindex_quartz[NUMENTRIES_quartz] = {
		1.661,1.632,1.622,1.619,1.602,1.596,
		1.585,1.576,1.571,1.565,1.558,1.552,
		1.55,1.548,1.547,1.544,1.543,1.541,
		1.539,1.541,1.539,1.538,1.538,1.537,
		1.535,1.534,1.531,1.528,1.521};

	G4double absorp_quartz[NUMENTRIES_quartz] = {
		3.0*cm,3.0*cm,3.0*cm,3.0*cm,3.0*cm,3.0*cm,
		3.0*cm,3.0*cm,3.0*cm,3.0*cm,3.0*cm,3.0*cm,
		3.0*cm,3.0*cm,3.0*cm,3.0*cm,3.0*cm,3.0*cm,
		3.0*cm,3.0*cm,3.0*cm,3.0*cm,3.0*cm,3.0*cm,
		3.0*cm,3.0*cm,3.0*cm,3.0*cm,3.0*cm};

	G4MaterialPropertiesTable *quartz_mt = new G4MaterialPropertiesTable();
	quartz_mt->AddProperty("RINDEX", 	energy_quartz, rindex_quartz, NUMENTRIES_quartz);
	quartz_mt->AddProperty("ABSLENGTH", energy_quartz, absorp_quartz, NUMENTRIES_quartz);
	quartz->SetMaterialPropertiesTable(quartz_mt);

	//----------wolfram________________
	//Note____ if RINDEX is not supllied the optical photons will be killed in that material
	wolfram   = man->FindOrBuildMaterial("G4_W");
	const G4int wolfram_NUMENTRIES=2;
	G4double wolfram_Energy[wolfram_NUMENTRIES]={2.0*eV,7.14*eV};
	G4double wolfram_RIND[wolfram_NUMENTRIES]={3.6,1.06};
	G4double wolfram_abs[wolfram_NUMENTRIES]={0.55e-6*cm,0.55e-6*cm};//not sure about this, but should be small
	G4MaterialPropertiesTable *wolfram_mt = new G4MaterialPropertiesTable();
	wolfram_mt->AddProperty("RINDEX", wolfram_Energy, wolfram_RIND,wolfram_NUMENTRIES);
	wolfram_mt->AddProperty("ABSLENGTH", wolfram_Energy, wolfram_abs,wolfram_NUMENTRIES);
	wolfram->SetMaterialPropertiesTable(wolfram_mt);

	//---------air & vacuum________________
	air     = man->FindOrBuildMaterial("G4_AIR");
	vacuum  = man->FindOrBuildMaterial("G4_Galactic");
	const G4int vacuum_NUMENTRIES=3;
	G4double vacuum_Energy[vacuum_NUMENTRIES]={2.0*eV,7.0*eV,7.14*eV};
	G4double vacuum_RIND[vacuum_NUMENTRIES]={1.,1.,1.};  
	G4MaterialPropertiesTable *vacuum_mt = new G4MaterialPropertiesTable();
	vacuum_mt->AddProperty("RINDEX", vacuum_Energy, vacuum_RIND,vacuum_NUMENTRIES);
	vacuum->SetMaterialPropertiesTable(vacuum_mt);
	air->SetMaterialPropertiesTable(vacuum_mt);//Give air the same rindex


	//---------Glass & Aluminum________________

	const G4int lxenum = 3;
	G4double sc_Energy[lxenum]    = { 2.3*eV , 3.0*eV, 3.3*eV };
	// 2.36 eV 3.3 eV 

	//Glass
	fGlass = new G4Material("Glass", density=1.032*g/cm3,2);
	fGlass->AddElement(C,91.533*perCent);
	fGlass->AddElement(H,8.467*perCent);

	G4double glass_RIND[lxenum]={1.49,1.49,1.49};
	G4double glass_AbsLength[lxenum]={420.*cm,420.*cm,420.*cm};
	G4MaterialPropertiesTable *glass_mt = new G4MaterialPropertiesTable();
	glass_mt->AddProperty("ABSLENGTH",sc_Energy,glass_AbsLength,lxenum);
	glass_mt->AddProperty("RINDEX",sc_Energy,glass_RIND,lxenum);
	fGlass->SetMaterialPropertiesTable(glass_mt);

	//Aluminum
	fAl = new G4Material("Al",z=13.,a=26.98*g/mole,density=2.7*g/cm3);

	/*
	   -  Reflectivity or reflectance is the fraction of incident electromagnetic power that is reflected at an interface
	   -  The refractive index or index of refraction n of a substance (optical medium) is defined as
	   n=\frac{c}{v}
	 */

}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
G4VPhysicalVolume* DetectorConstruction::Construct(){
	DefineMaterials();
	return ConstructDetector();
}
//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
G4VPhysicalVolume* DetectorConstruction::ConstructDetector()
{
	//------------------------------
	// World
	//------------------------------
	
	//G4GeometryManager::GetInstance()->SetWorldMaximumExtent(2.*halfWorldLength);
	//G4cout << "Computed tolerance = "<< G4GeometryTolerance::GetInstance()->GetSurfaceTolerance()/mm << " mm" << G4endl;

	G4Box * worldSolid= new G4Box("sWorld",halfWorldLength,halfWorldLength,halfWorldLength);
	worldLogic= new G4LogicalVolume( worldSolid, vacuum, "lWorld", 0, 0, 0);

	//  Must place the World Physical volume unrotated at (0,0,0).
	G4VPhysicalVolume * worldPhys= 
		new G4PVPlacement(0,     // no rotation
				G4ThreeVector(), // at (0,0,0)
				worldLogic,      // its logical volume
				"pWorld",        // its name
				0,               // its mother  volume
				false,           // no boolean operations
				0);              // copy number

	//------------------------------
	//EM calorimeter
	//------------------------------
	ConstructEMCalo();

	//------------------------------
	//PMTs
	//------------------------------
	ConstructPMTs();

	//------------------------------
	//Magnetic Field
	//------------------------------
	//ConstructField(); 

	//Visualization attributes
	SetVisibilityAttributes();

	//always return the physical World
	return worldPhys;
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
G4VPhysicalVolume* DetectorConstruction::ConstructEMCalo()
{

	/*
	 * create a Wolfram block
	 * place the Quartz tubes
	 * in each tube place a scint. core
	 * define optical boundaries
	 */

	//-----------------------------------------------------------------------
	//-------create the W block volume
	//-----------------------------------------------------------------------
	G4double halfEmCaloSizeX = emCaloWidth/2;
	G4double halfEmCaloSizeY = emCaloWidth/2;
	G4double halfEmCaloSizeZ = emCaloLength/2;

	//make solid, logic & phys
	G4Box* caloSolid = new G4Box("sCalo",halfEmCaloSizeX,halfEmCaloSizeY,halfEmCaloSizeZ);
	
	caloLogic = new G4LogicalVolume( caloSolid,//its solid
			wolfram, //material
			"lCalo");//its name
	
	caloPhys = new G4PVPlacement(0,     //no rotation
			posEmCalo,					//translation
			caloLogic, 					//logical volume
			"pCalo",					//name
			worldLogic,					//mother volume
			false, 						//no boolean operation
			1); 						//copy number


	//create & place tubes (capillary+core)
	ConstructTubes();

	//inside Wolfram do not follow electrons with energy below 511 keV
	//caloLogic->SetUserLimits(new G4UserLimits(DBL_MAX,DBL_MAX,DBL_MAX,511*keV));

	//----------------------------------------------------------
	//				OPTICAL BOUNDARIES
	//----------------------------------------------------------
	/*TODO check with somebody if this is correct !! 
	  WHEN MAKING a boundary a-->b logical border surface should be given as
	  (name, a, b, surfacename_ab)
	  Also, If one can expect particles (opt photons) going from b-->a
	  additional optSurface has to be constructed
	 * (name, b, a, surfacename_ba)
	 */

	// 1) Optical boundary between Quartz-Wolfram 
	G4OpticalSurface * outTubeSurface = new G4OpticalSurface("QuartzWolfram");
	new G4LogicalBorderSurface("QuartzWolfram", 
			capillaryPhys, 
			caloPhys,
			outTubeSurface);

	/*
	   DIELECTRIC - METAL; Unified model!
	   No REFRACTION! 
	   If Finish *ground*   Only ABSORPTION or REFLECTION 
	   If Finish *polished* Only ABSORPTION or REFLECTION; if reflected then is SpecularSpike reflection 
	 */
	outTubeSurface->SetType(dielectric_metal);
	outTubeSurface->SetModel(unified);
	outTubeSurface->SetFinish(ground);

	const G4int NUM1 =2;
	//from http://refractiveindex.info/?group=METALS&material=Tungsten
	G4double pp1[NUM1] = {2.36*eV, 3.31*eV};
	G4double efficiency1[NUM1] = {0.0, 0.0}; //
	G4double reflectivity1[NUM1] = {0.45, 0.45};//reflection probability of tungsten 

	G4MaterialPropertiesTable* outTubeSurfaceProperty  = new G4MaterialPropertiesTable();
	outTubeSurfaceProperty->AddProperty("REFLECTIVITY",pp1,reflectivity1,NUM1);
	outTubeSurfaceProperty->AddProperty("EFFICIENCY",pp1,efficiency1,NUM1);
	outTubeSurface->SetMaterialPropertiesTable(outTubeSurfaceProperty);


	// 2) Optical boundary between  EJ309-Quartz 
	G4OpticalSurface * inTubeSurface = new G4OpticalSurface("EJ309Quartz");
	inTubeSurface->SetType(dielectric_dielectric);
	inTubeSurface->SetModel(unified);
	inTubeSurface->SetFinish(polished);

	/*
	   DIELECTRIC - DIELECTRIC; Unified model!
	   If Finish *polished* 

	   1) Snell's Law is applied based on *REFRACTIVE* index of the two media. 

	   2)But before this, REFLECTIVITY is used to determine whether photon is absorbed.
	   Strictly speaking here REFLECTIVITY is not the reflection coefficient, but (1 - absorption_coefficient).

	   NOTE___ absorption coefficient = 1/absorption length??
	 */
	new G4LogicalBorderSurface("EJ309->Quartz", 
			corePhys,
			capillaryPhys,
			inTubeSurface);


	new G4LogicalBorderSurface("Quartz->EJ309", 
			capillaryPhys,
			corePhys,
			inTubeSurface);

	const G4int NUM = 2;
	//from http://refractiveindex.info/
	G4double pp[NUM] = {2.36*eV, 3.31*eV};
	G4double reflectivity[NUM] = {1, 1};//;
	G4double efficiency[NUM] = {0.0, 0.0}; // 

	G4MaterialPropertiesTable* inTubeSurfaceProperty  = new G4MaterialPropertiesTable();
	inTubeSurfaceProperty->AddProperty("REFLECTIVITY"	,pp,	reflectivity,NUM);
	inTubeSurfaceProperty->AddProperty("EFFICIENCY"		,pp,	efficiency,NUM);
	inTubeSurface->SetMaterialPropertiesTable(inTubeSurfaceProperty);

	return caloPhys;

}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
void DetectorConstruction::SetDiceType(G4bool b){
	dice5=b;
	fUpdated=true;
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

void DetectorConstruction::SetPMTzDistance(G4double z){
	pmtZ = z;
	fUpdated=true;
}
//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......


void DetectorConstruction::UpdateGeometry(){

	// clean-up previous geometry
	G4GeometryManager::GetInstance()->OpenGeometry();

	G4PhysicalVolumeStore::GetInstance()->Clean();
	G4LogicalVolumeStore::GetInstance()->Clean();
	G4SolidStore::GetInstance()->Clean();
	G4LogicalSkinSurface::CleanSurfaceTable();
	G4LogicalBorderSurface::CleanSurfaceTable();
	G4SurfaceProperty::CleanSurfacePropertyTable();

	//define the new one
	G4RunManager::GetRunManager()->DefineWorldVolume(Construct());
	G4RunManager::GetRunManager()->GeometryHasBeenModified();

	fUpdated=false;
}


//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
//G4LogicalVolume* DetectorConstruction::ConstructTubes()
void DetectorConstruction::ConstructTubes()
{
	//dimensions
	G4double innerR = 0.0*mm;
	G4double halfEmCaloSizeZ = emCaloLength/2;

	//Setup Sensitive Detectors***************
	//Created here so it exists as tubes are being placed
	if(!fScint_SD){//determine if it has already been created
		fScint_SD = new SPcScintSD("/SPcDet/scintSD");
		SDman->AddNewDetector(fScint_SD);
	}

	//Capillary
	G4Tubs* capillarySolid = new G4Tubs("sCapillary",
			innerR,		        //inner r  
			capillaryOutherR,	//outher r
			halfEmCaloSizeZ,	//length
			0,					//start angle
			CLHEP::twopi);		//end angle	
	capillaryLogic = new G4LogicalVolume(capillarySolid, quartz, "lCapillary");


	//Core
	G4Tubs* coreSolid = new G4Tubs("sCore",
			innerR,			//inner r 
			coreOutherR,	//outher r
			halfEmCaloSizeZ,//length
			0,				//start angle
			CLHEP::twopi);	//end angle	

	coreLogic = new G4LogicalVolume(coreSolid, ej309, "lCore");

	//Place the core inside the capillary
	G4ThreeVector position(0, 0, 0);
	corePhys = new G4PVPlacement( 0 , 
			position, 
			coreLogic , 	//logic
			"pCore", 		//name 
			capillaryLogic,	//mother
			false, 
			10);


	//the core is sensitive detector
	coreLogic->SetSensitiveDetector(fScint_SD);
	//------------------------------------------------ 
	//Place capillaries using parametrisation
	//------------------------------------------------ 
	int noHoles(0);
	int brX = int(emCaloWidth/pitch);
	if( brX%2 ) noHoles= (brX - 1)*(brX - 1);
	else noHoles = brX*brX;


	G4VPVParameterisation* tubeParam = new TubeParameterisation(
			pitch,
			emCaloWidth,
			emCaloLength,
			capillaryOutherR,
			dice5
			);


	capillaryPhys = new G4PVParameterised(
			"pCapillary",  //name
			capillaryLogic,//their logic
			caloLogic,     //mother logic
			kXAxis,		   //how they are placed
			noHoles,       //total number
			tubeParam, 	   //the parametrisation
			false);		   //check for overlaping

}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
void DetectorConstruction::ConstructPMTs()
{
	// Build PMTs
	G4double halfSide = 0.48*cm;
	G4double height_pmt = fD_mtl/2.; //this is actually half height

	pmtSolid = new G4Box("sPmt",halfSide,halfSide,height_pmt);
	pmtLogic = new G4LogicalVolume(pmtSolid,
			G4Material::GetMaterial("Glass"),
			"lPmt");

	//the "photocathode" is a metal slab at the back of the glass that
	//is only a very rough approximation of the real thing since it only
	//absorbs or detects the photons based on the efficiency set below
	photocathSolid = new G4Box("sPhotocath", halfSide, halfSide, height_pmt/2);
	photocathLogic = new G4LogicalVolume(photocathSolid,
			G4Material::GetMaterial("Al"),
			"lPhotocath");

	//place photocath inside pmt
	new G4PVPlacement(0,						//no rotation
			G4ThreeVector(0,0,height_pmt/2),    //translation
			photocathLogic,						//it's log volume
			"pPhotocath",						//it's name
			pmtLogic,							// mother volume
			false,								//
			0);									// copy no


	//Arrange pmts **********
	//pmt sensitive detector
	if(!fPmt_SD){
		fPmt_SD = new SPcPMTSD("/SPcDet/pmtSD");
		SDman->AddNewDetector(fPmt_SD);
		//Created here so it exists as pmts are being placed
	}
	fPmt_SD->InitPMTs(fNx*fNy); //let pmtSD know # of pmts
	//-------

	G4double dx =(halfSide)*2 ;
	G4double dy = (halfSide)*2;
	G4double x,y,z; 
	G4double xmin = -emCaloWidth/2.0 + dx/2. + 0.4*mm;
	G4double ymin = -emCaloWidth/2.0 + dy/2.+ 0.4*mm;

	z = pmtZ;

	x=xmin;
	G4int k =0;
	for(G4int j=1;j<=fNx;j++){
		y=ymin;
		for(G4int i=1;i<=fNx;i++){
			new G4PVPlacement(0,			//no rotation
					G4ThreeVector(x,y,z),   //translation
					pmtLogic,               //it's log volume
					"pPmt",                  //it's name
					worldLogic,             // mother volume
					false,                  //
					k);                     // copy no
			k++;
			y+=dy;
		}
		x+=dx;
	}



	//sensitive detector is not actually on the photocathode.
	//processHits gets done manually by the stepping action.
	//It is used to detect when photons hit and get absorbed&detected at the
	//boundary to the photocathode (which doesnt get done by attaching it to a
	//logical volume.
	//It does however need to be attached to something or else it doesnt get
	//reset at the begining of events

	photocathLogic->SetSensitiveDetector(fPmt_SD);


	//Photocathode surface properties
	const G4int num = 2;
	G4double ephoton[num] = {2.0*eV, 3.3*eV};
	G4double photocath_EFF[num]={1.,1.}; //Enables 'detection' of photons
	G4double photocath_ReR[num]={1.92,1.92};
	G4double photocath_ImR[num]={1.69,1.69};
	G4MaterialPropertiesTable* photocath_mt = new G4MaterialPropertiesTable();
	photocath_mt->AddProperty("EFFICIENCY",ephoton,photocath_EFF,num);
	photocath_mt->AddProperty("REALRINDEX",ephoton,photocath_ReR,num);
	photocath_mt->AddProperty("IMAGINARYRINDEX",ephoton,photocath_ImR,num);

	G4OpticalSurface* photocath_opsurf=  new G4OpticalSurface("photocath_opsurf",glisur,polished,dielectric_metal);
	photocath_opsurf->SetMaterialPropertiesTable(photocath_mt);

	//Create logical skin surfaces
	new G4LogicalSkinSurface("photocath_surf",photocathLogic,photocath_opsurf);
}


//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
void DetectorConstruction::SetVisibilityAttributes()
{
	G4Colour  white   (1.0, 1.0, 1.0) ;  // white
	G4Colour  ogray    (0.5, 0.5, 0.5) ;  // gray
	G4Colour  darkgray (0.75, 0.75, 0.75) ;  // dark gray
	G4Colour  black   (0.0, 0.0, 0.0) ;  // black
	G4Colour  red     (1.0, 0.0, 0.0) ;  // red
	G4Colour  green   (0.0, 1.0, 0.0) ;  // green
	G4Colour  blue    (0.0, 0.0, 1.0) ;  // blue
	G4Colour  cyan    (0.0, 1.0, 1.0) ;  // cyan
	G4Colour  magenta (1.0, 0.0, 1.0) ;  // magenta
	G4Colour  yellow  (1.0, 1.0, 0.0) ;  // yellow
	G4Colour  medyellow  (0.75, 0.75, 0.0) ;  // medium yellow


	// Make invisible
	inVisAtt = new G4VisAttributes(black); 
	//inVisAtt->SetVisibility(false);

	// White
	whiteVisAtt = new G4VisAttributes(white);
	//whiteVisAtt->SetVisibility(true);
	//whiteVisAtt->SetForceSolid(true);

	// Dark Grey
	dkgreyVisAtt = new G4VisAttributes(darkgray);
	//dkgreyVisAtt->SetVisibility(true);
	//dkgreyVisAtt->SetForceSolid(true);

	// Medium Yellow
	medyelVisAtt = new G4VisAttributes(medyellow);
	//medyelVisAtt->SetVisibility(true);
	//medyelVisAtt->SetForceSolid(true);

	// Yellow
	yellowVisAtt = new G4VisAttributes(yellow);
	//yellowVisAtt->SetVisibility(true);
	//yellowVisAtt->SetForceSolid(true);

	// Red
	redVisAtt = new G4VisAttributes(red);
	//redVisAtt->SetVisibility(true);
	//redVisAtt->SetForceSolid(true);

	greenVisAtt = new G4VisAttributes(green);
	blueVisAtt = new G4VisAttributes(blue);

	//asign vis atributes to the logical volumes

	//world
	worldLogic -> SetVisAttributes(whiteVisAtt);
	worldLogic -> SetVisAttributes(G4VisAttributes::Invisible);

	//W block
	caloLogic->SetVisAttributes(yellowVisAtt);

	//capillaries
	capillaryLogic->SetVisAttributes(redVisAtt);

	//core
	coreLogic->SetVisAttributes(greenVisAtt);
   

	// ogray
	ograyVisAtt = new G4VisAttributes(ogray);
	//whiteVisAtt->SetVisibility(true);
	ograyVisAtt->SetForceSolid(true);

	//photocathLogic->SetVisAttributes(greenVisAtt);
	photocathLogic->SetVisAttributes(ograyVisAtt);
    

}
//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

